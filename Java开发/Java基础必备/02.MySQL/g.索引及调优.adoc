= 索引及调优
:source-highlighter: highlight.js
:source-language: sql
:toc: left
:toc-title: 索引及调优
:toclevels: 3
:sectnums:

== 索引的数据结构
详情见link:_g.索引的数据结构.pdf[索引的数据结构]。

== 索引的创建与设计原则
=== 索引的分类
- 从功能逻辑上说，索引主要有 4 种，分别是普通索引、唯一索引、主键索引、全文索引。
- 按照物理实现方式，索引可以分为 2 种：聚簇索引和非聚簇索引。
- 按照作用字段个数进行划分，分成单列索引和联合索引。

=== 不同存储引擎对索引类型的支持
- InnoDB：支持 B-tree、Full-text 等索引，不支持 Hash索引；
- MyISAM： 支持 B-tree、Full-text 等索引，不支持 Hash 索引；
- Memory：支持 B-tree、Hash 等索引，不支持 Full-text 索引；
- NDB：支持 Hash 索引，不支持 B-tree、Full-text 等索引；
- Archive：不支持 B-tree、Hash、Full-text 等索引。

=== 索引的创建与删除
==== 创建索引
创建主键约束、唯一性约束、外键约束时会自动创建对应索引。

.建表时显式创建
----
CREATE TABLE table_name [col_name data_type]
[UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name [length]) [ASC |
DESC] <1>
----
<1> FULLTEXT：全文索引；SPATIAL：空间索引，空间类型的字段必须为非空。

.建表后创建
----
ALTER TABLE table_name ADD [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY]
[index_name] (col_name[length],...) [ASC | DESC]

# 或

CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name
ON table_name (col_name[length],...) [ASC | DESC]
----

==== 删除索引
----
ALTER TABLE table_name DROP INDEX index_name;
# 或
DROP INDEX index_name ON table_name;
----

=== MySQL8.0索引新特性
==== 降序索引
===== 概述
降序索引以降序存储键值。虽然在语法上，从MySQL4版本开始就已经支持降序索引的语法了，但实际上该DESC定义是被忽略的，直到MysQL8.x版本才开始真正支持降序素引（仅限于InnoDB存储引擎）。

MySQL在8.0版本之前创建的仍然是升序索引，使用时进行反向扫描，这大大降低了数据库的效率。在某些场景下，降序索引意义重大。例如，如果一个查询，需要对多个列进行排序，且顺序要求不一致，那么使用降序索引将会避免数据库使用额外的文件排序操作，从而提高性能。

===== 语法
----
CREATE TABLE ts1(a int,b int,index idx_a_b(a ASC,b DESC));
----

==== 隐藏索引
===== 概述
在MySQL 5.7版本及之前，只能通过显式的方式删除索引。此时，如果发现删除索引后出现错误，又只能通过显式创建索引的方式将删除的索引创建回来。如果数据表中的数据量非常大，或者数据表本身比较大，这种操作就会消耗系统过多的资源，操作成本非常高。

从MySQL 8.x开始支持 隐藏索引（invisible indexes） ，只需要将待删除的索引设置为隐藏索引，使查询优化器不再使用这个索引（即使使用force index（强制使用索引），优化器也不会使用该索引），确认将索引设置为隐藏索引后系统不受任何响应，就可以彻底删除索引。 这种通过先将索引设置为隐藏索引，再删除索引的方式就是软删除 。

NOTE: 主键不能被设置为隐藏索引。当表中没有显式主键时，表中第一个唯一非空索引会成为隐式主键，也不能设置为隐藏索引。

===== 创建隐藏索引
.建表时
----
CREATE TABLE tablename(
propname1 type1[CONSTRAINT1],
propname2 type2[CONSTRAINT2],
……
propnamen typen,
INDEX [indexname](propname1 [(length)]) INVISIBLE
);
----

.建表后
----
CREATE INDEX indexname
ON tablename(propname[(length)]) INVISIBLE;
# 或
ALTER TABLE tablename
ADD INDEX indexname (propname [(length)]) INVISIBLE;
----

===== 切换索引可见状态
----
ALTER TABLE tablename ALTER INDEX index_name INVISIBLE; #切换成隐藏索引
ALTER TABLE tablename ALTER INDEX index_name VISIBLE; #切换成非隐藏索引
----

===== 使隐藏索引对查询优化器可见
在MySQL 8.x版本中，为索引提供了一种新的测试方式，可以通过查询优化器的一个开关（use_invisible_indexes）来打开某个设置，使隐藏索引对查询优化器可见。如果 use_invisible_indexes设置为off(默认)，优化器会忽略隐藏索引。如果设置为on，即使隐藏索引不可见，优化器在生成执行计划时仍会考虑使用隐藏索引。

.查看隐藏索引对查询优化器是否可见
----
select @@optimizer_switch
----
.设置为可见
----
set session optimizer_switch="use_invisible_indexes=on";
----

=== 索引的设计原则
==== 适合创建索引的情况
- 字段的数值有唯一性的限制
- 频繁作为 WHERE 查询条件的字段
- 经常 GROUP BY 和 ORDER BY 的列
- UPDATE、DELETE 的 WHERE 条件列
- DISTINCT 字段需要创建索引
- 多表 JOIN 连接操作时，创建索引注意事项
* 连接表的数量尽量不要超过 3 张
* 对 WHERE 条件创建索引
* 对用于连接的字段创建索引，且该字段在多张表中的 类型必须一致
- 使用列的类型小的创建索引，如INT和TINYINT中尽量选择后者
- [[使用字符串前缀创建索引]]使用字符串前缀创建索引
+
[NOTE]
====
计算不同的长度的选择性：

.先看一下字段在全部数据中的选择度
----
select count(distinct address) / count(*) from shop;
----
.通过不同长度去计算，与全表的选择性对比
----
count(distinct left(列名, 索引长度))/count(*)
----
====
- 区分度高(散列性高)的列适合作为索引
+
NOTE: 可以使用公式 `select count(distinct a)/count(*)from t1` 计算区分度，越接近1越好，一般超过33%就算是比较高效的索引。
- 使用最频繁的列放到联合索引的左侧
- 在多个字段都要创建索引的情况下，联合索引优于单值索引

==== 限制索引的数目
在实际工作中，我们也需要注意平衡，索引的数目不是越多越好。我们需要限制每张表上的索引数量，建议单张表索引数量不超过6个。

.原因：
- 每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大。
- 索引会影响INSERT、DELETE、UPDATE等语句的性能，因为表中的数据更改的同时，索引也会进行调整和更新，会造成负担。
- 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，会增加MySQL优化器生成执行计划时间，降低查询性能。

==== 不适合创建索引的情况
- 在where中使用不到的字段，不要设置索引
- 数据量小的表最好不要使用索引
+
NOTE: 在数据表中的数据行数比较少的情况下，比如不到 1000 行，是不需要创建索引的。
- 有大量重复数据的列上不要建立索引
+
NOTE: 当数据重复度大，比如 高于 10% 的时候，也不需要对这个字段使用索引。
- 避免对经常更新的表创建过多的索引
- 不建议用无序的值作为索引
+
NOTE: 例如身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字符串等。
- 删除不再使用或者很少使用的索引
- 不要定义冗余或重复的索引

== 性能分析工具的使用
详情见link:_g.性能分析工具的使用.pdf[性能分析工具的使用]。

参考代码：link:_g.EXPLAIN的使用.adoc[EXPLAIN的使用]。

=== 补充
==== 慢查询日志分析工具mysqldumpslow[接链接4.5]
除了上述变量，控制慢查询日志的还有一个系统变量：`min_examined_row_limit`。这个变量的意思是，查询扫描过的最少记录数。这个变量和查询执行时间，共同组成了判别一个查询是否是慢查询的条件。如果查询扫描过的记录数大于等于这个变量的值，并且查询执行时间超过 `long_query_time` 的值，那么，这个查询就被记录到慢查询日志中；反之，则不被记录到慢查询日志中。

这个值默认是0。与 `long_query._time=10` 合在一起，表示只要查询的执行时间超过10秒钟，哪怕一个记录也没有扫描过，都要被记录到慢查询日志中。你也可以根据需要，通过修改“my.ii”文件，来修改查询时长，或者通过SET指令，用SQL语句修改 `min_examined_row_limit` 的值。

==== 删除慢查询日志[接链接2.7]
- 删除
* 使用SHOW语句显示慢查询日志信息
+
----
SHOW VARIABLES LIKE 'slow_query_log%';
----
* 慢查询日志的目录默认为MySQL的数据目录，在该目录下手动别除慢查询日志文件即可。
- 初始化
* 使用命令mysqladmin f1ush-logs来重新生成查询日志文件，命令如下，执行完毕会在数据目录下重新生成慢查询日志文件。
+
----
mysqladmin -uroot -p flush-logs slow
----

==== 日常开发需注意的结论[接链接5]
- converting HEAP to MyISAM:查询结果太大，内存不够，数据往磁盘上搬了。
- Creating tmp table:创建临时表。先拷贝数据到临时表，用完后再删除临时表。
- Copying to tmp table on disk:把内存中临时表复制到磁盘上，警惕！
- locked

如果在 `show profilei` 诊断结果中出现了以上4条结果中的任何一条，则sql语句需要优化。

NOTE: SHOW PROFILE命令将被弃用，我们可以从information_schema中的profiling数据表进行查看。

== 索引优化与查询优化
=== 索引失效的注意情况
- 索引字段争取**全值匹配**，越多越好。
- 遵守**最左前缀原则**。
+
NOTE: 索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。
- 让**主键具有 AUTO_INCREMENT**。
+
NOTE: 让存储引擎自己为表生成主键，这样的主键占用空间小，顺序写入，减少页分裂。
- 计算、函数、类型转换(自动或手动)会导致索引失效。
- 范围条件（例如：>、<）右边的列索引会失效。
+
NOTE: 创建索引时将涉及范围查询条件的字段放置语句最后。
- 涉及不等于(!= 或者<>)时索引可能会失效。
-  is null可以使用索引，is not null无法使用索引。
+
NOTE: 最好在设计数据表的时候就将字段设置为NOT NULL约束，比如可以将INT类型的字段，默认值设置为0。将字符类型的默认值设置为空字符串（''）。同理，在查询中使用not 1ike也无法使用索引，导致全表扫描。
- like以通配符%开头时索引会失效。
+
NOTE: Alibaba《Java开发手册》 +
【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。
- OR 前后存在非索引的列，索引会失效。
- 数据库和表的字符集**要统一使用utf8mb4**。
+
NOTE: 统一使用utf8mb4( 5.5.3版本以上支持)兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不同的字符集进行比较前需要进行转换会造成索引失效。

=== 关联查询优化
==== JOIN语句原理
- Simple Nested-Loop Join(简单嵌套循环连接）
- Index Nested-Loop Join(索引嵌套循环连接）
- Block Nested-Loop Join(块嵌套循环连接）

.Hash Join
从MySQL的8.0.20版本开始将废弃BNLJ,因为从MySQL8.0.18版本开始就加入了hash join，默认都会使用hash join。

以上内容建议观看视频： https://www.bilibili.com/video/BV1iq4y1u7vj?p=144[JOIN语句的底层原理]

===== 小结
. 整体效率比较：INLJ>BNLJ>SNLJ
. 永远用小结果集驱动大结果集（其本质就是减少外层循环的数据数量）（小的度量单位指的是表行数*每行大小）
. 为被驱动表匹配的条件增加索引（减少内层表的循环匹配次数）
. 增大join buffer size的大小(一次缓存的数据越多，那么内层包的扫表次数就越少)
. 减少驱动表不必要的字段查询(join buffer中包含驱动表中和被驱动表连接条件的字段和查询语句select中的字段。字段越少，join buffer所缓存的数据就越多)

=== 子查询优化
子查询可以通过一个 SQL 语句实现比较复杂的查询。但是，子查询的执行效率不高。原因如下：

- 执行子查询时，MySQL需要为内层查询语句的查询结果**建立一个临时表** ，然后外层查询语句从临时表中查询记录。查询完毕后，再撤销这些临时表 。这样会**消耗过多的CPU和IO资源，产生大量的慢查询**。
- 子查询的结果集存储的**临时表**，不论是内存临时表还是磁盘临时表都**不会存在索引**，所以查询性能会受到一定的影响。
- 对于返回结果集比较大的子查询，其对查询性能的影响也就越大。

NOTE: 在MySQL中，可以使用连接（JOIN）查询来替代子查询。尽量不要使用NOT IN 或者 NOT EXISTS，替代的同时，可以用LEFT JOIN xxx ON xx WHERE xx IS NULL替代。

=== 排序优化
==== 排序优化
在WHERE条件字段上加索引，在ORDER BY字段上也要加索引。 +
原因：

- 在MySQL中，支持两种排序方式，分别是FileSort和Index排序。
- Index排序中，索引可以保证数据的有序性，不需要再进行排序，效率更高。
- FileSort排序则一般在内存中进行排序，占用CPU较多。如果待排结果较大，会产生临时文件I/O到磁盘进行排序的情况，效率较低。

.优化建议
- SQL 中，可以在 WHERE 子句和 ORDER BY 子句中使用索引，目的是在 WHERE 子句中 避免全表扫描 ，在 ORDER BY 子句 避免使用 FileSort 排序 。当然，某些情况下全表扫描，或者 FileSort 排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。
- 尽量使用 Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY 后面是相同的列就使用单索引列；如果不同就使用联合索引。
- 无法使用 Index 时，需要对 FileSort 方式进行调优。

==== filesort算法：双路排序和单路排序
- 双路排序 （慢）
* MySQL 4.1之前是使用双路排序 ，意思就是两次扫描磁盘，最终得到数据，读取行指针和order by列 ，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出。
* 从磁盘取排序字段，在buffer进行排序，再从 磁盘取其他字段 。

- 单路排序 （快）
* 从磁盘读取查询需要的所有列，按照order by列在buffer对它们进行排序，然后扫描排序后的列表进行输出， 它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO。

.优化策略
. 尝试提高 sort_buffer_size
. 尝试提高 max_length_for_sort_data
* 提高这个参数，会增加用改进算法的概率。
. Order by 时select * 是一个大忌。最好只Query需要的字段。
* 当QueryE的字段大小总和小于max_length_for_sort_data,而且排序字段不是TEXT|BLOB类型时，会用改进后的算法一一单路排序，否则用老算法一一多路排序。

=== GROUP BY优化
- group by 使用索引的原则几乎跟order by一致 ，group by 即使没有过滤条件用到索引，也可以直接使用索引。
- group by 先排序再分组，遵照索引建的最佳左前缀法则
- 当无法使用索引列，增大 max_length_for_sort_data 和 sort_buffer_size 参数的设置
- where效率高于having，能写在where限定的条件就不要写在having中
- 减少使用order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。Order by、group by、distinct这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。
- 包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集应保持在1000行以内，否则SQL会很慢。

=== 优化分页查询
==== 化思路一
在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。
.例
----
EXPLAIN SELECT * FROM student t,(SELECT id FROM student ORDER BY id LIMIT 2000000,10) a
WHERE t.id = a.id;
----

==== 优化思路二
该方案适用于主键自增的表，可以把Limit查询转换成某个位置的查询。
.例
----
EXPLAIN SELECT * FROM student WHERE id > 2000000 LIMIT 10;
----

=== 优先考虑覆盖索引
==== 概念
覆盖索引指的是索引列+主键包含SELECT到FROM之间查询的列。

NOTE: 优化器会优先考虑覆盖索引，例如当覆盖索引和模糊查询中的%x、范围查询中的<>等原本会使索引无效的情况同时存在时，可能覆盖索引仍会生效。

==== 覆盖索引的利弊
- 好处：
. 避免Innodb表进行索引的二次查询（回表）
. 可以把随机IO变成顺序IO加快查询效率

- 弊端：
索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这是业务DBA，或者称为业务数据架构师的工作。

=== 前缀索引
具体使用见适合创建索引的情况中的<<使用字符串前缀创建索引>>。

IMPORTANT: 使用前缀索引就用不上覆盖索引对查询性能的优化，这也是在选择是否使用前缀索引时需要考虑的一个因素。

=== 索引下推
==== 概述
Index Condition Pushdown(ICP)是MySQL 5.6中新特性，是一种在存储引擎层使用索引过滤数据的一种优化方式。ICP可以减少存储引擎访问基表的次数以及MySQL服务器访问存储引擎的次数。

==== ICP的开启/关闭
默认是开启状态。

.关闭索引下推
----
SET optimizer_switch = 'index_condition_pushdown=off';
----
.打开索引下推
----
SET optimizer_switch = 'index_condition_pushdown=on';
----

==== 是否使用ICP扫描的对比
===== 使用ICP扫描的过程
首先将index key条件满足的索引记录区间确定，然后在索引上使用index filter进行过滤。将满足的index filter条件的索引记录才去回表取出整行记录返回server层。

===== 在不使用ICP索引扫描的过程
将满足index key条件的索引记录对应的整行记录取出，然后使用where条件过滤。

==== ICP的使用条件
- 只能用于二级索引(secondary index)。
- explain显示的执行计划中type值（join 类型）为 range 、 ref 、 eq_ref 或者 ref_or_null。
-  并非全部where条件都可以用ICP筛选，如果where条件的字段不在索引列中，还是要读取整表的记录到server端做where过滤。
- ICP可以用于MyISAM和InnnoDB存储引擎。
- MySQL 5.6版本的不支持分区表的ICP功能，5.7版本的开始支持。
- 当SQL使用覆盖索引时，不支持ICP优化方法。
- 相关子查询不能使用ICP。

=== 普通索引 vs 唯一索引
==== 查询过程对比
- 对于普通索引来说，查找到满足条件的第一个记录后，需要查找下一个记录，直到碰到第一个不满足条件的记录。
- 对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检
索。

==== 更新过程
普通索引的更新使用change buffer，唯一索引不可以。

[discrete]
===== 关于change buffer
当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB会将这些更新操作缓存在change buffer中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。

将change buffer中的操作应用到原数据页，得到最新结果的过程称为merge。除了 访问这个数据页会触发merge外，系统有后台线程会定期merge。在数据库正常关闭（shutdown）的过程中，也会执行merge操作。

如果能够将更新操作先记录在change buffer，减少读磁盘，语句的执行速度会得到明显的提升。而且，数据读入内存是需要占用 buffer pool的，所以这种方式还能够避免占用内存，提高内存利用率。

==== 使用场景分析
- 在实际使用中会发现，普通索引和change buffer的配合使用，对于数据量大的表的更新优化还是很明显的。
- 这两类索引在查询能力上是没差别的，主要考虑的是
对更新性能的影响。所以，建议尽量选择普通索引。
- 业务正确性要优先。我们的前提是“业务代码已经保证不会写入重复数据”的情况下，讨论性能问题。否则必须创建唯一索引。

=== 其它查询优化策略
==== EXISTS 和 IN 用哪个好？
索引是个前提，其实选择与否还是要看表的大小。可以将选择的标准理解为小表驱动大表。在这种方式下效率是最高的。

[discrete]
===== 举例说明
----
SELECT FROM A WHERE cc IN (SELECT cc FROM B)
SELECT FROM A WHERE EXISTS (SELECT cc FROM B WHERE B.cc=A.cc)
----

.当A小于B时，用EXISTS。因为EXISTS的实现，相当于外表循环，实现的逻辑类似于：
----
for i in A
    for j in B
        if j.cc =i.cc then ..
----
.当B小于A时用N,因为实现的逻辑类似于：
----
for i in B
    for j in A
        if j.cc =i.cc then ..
----

哪个表小就用哪个表来驱动，A表小就用EXISTS,B表小就用IN。

==== COUNT(*)、COUNT(1)与COUNT(具体字段)效率
===== 统计行数的区别
- COUNT(*)和COUNT(1)都是对WHERE过滤后数据行的统计。
- COUNT(具体字段)只统计该字段非null的行数。

===== 不同存储引擎的区别
- 如果是MyISAM存储引擎，统计数据表的行数只需要O(1)的复杂度。
* COUNT(*)最快，这是因为每张MyISAM的数据表都有一个meta信息存储了row_count值，而一致性则由表级锁来保证。
* count(1) 和 count(列名) 与 count(*) 的性能相似，因为MyISAM存储引擎不关心括号内的具体内容，只是简单地遍历表的行数来计算结果。
- 如果是InnoDB存储引擎，因为InnoDB支持事务，采用行级锁和MVCC机制，所以无法像MyISAM一样，维护一个row_count变量，因此需要采用扫描全表，是O(n)的复杂度，进行循环+计数的方式来完成统计。
* 如果采用COUNT（具体字段）来统计数据行数，要尽量采用二级索引。因为主键采用的索引是聚簇索引，聚簇索引包含的信息多，明显会大于二级索引（非聚簇索引）。
* 对于C0UNT(*)和C0UNT(1)来说，它们不需要查找具体的行，只是统计行数，系统会自动采用占用空间更小的二级索引来进行统计。如果有多个二级索引，会使用key_len小的二级索引进行扫描。当没有二级索引的时候，才会采用主键索引来进行统计。

==== 关于SELECT(*)
在表查询中，建议明确字段，不要使用 `*` 作为查询的字段列表，推荐使用SELECT <字段列表> 查询。 +
原因：

- MySQL 在解析的过程中，会通过查询数据字典将 `*` 按序转换成所有列名，这会大大的耗费资源和时间。
- 无法使用覆盖索引

==== LIMIT 1 对优化的影响
针对的是会扫描全表的SQL语句，如果可以确定结果集只有一条，那么加上LIMIT 1时，找到一条结果后就不会继续扫描，这样会加快查询速度。

如果数据表已经对字段建立了唯一索引，那么可以通过索引进行查询，不会全表扫描的话，就不需要加上LIMIT 1。

==== 多使用COMMIT
只要有可能，在程序中尽量多使用 COMMIT，这样程序的性能得到提高，需求也会因为 COMMIT 所释放的资源而减少。

.COMMIT 所释放的资源：
- 回滚段上用于恢复数据的信息
- 被程序语句获得的锁
- redo / undo log buffer 中的空间
- 管理上述3种资源中的内部花费

=== 淘宝数据库，主键如何设计的？
==== 自增ID的问题
自增ID做主键，简单易懂，几乎所有数据库都支持自增类型，只是实现上各自有所不同而已。自增ID除了简单，其他都是缺点，总体来看存在以下几方面的问题：

. 可靠性不高 +
存在自增ID回溯的问题，这个问题直到最新版本的MySQL 8.0才修复。
. 安全性不高 +
对外暴露的接口可以非常容易猜测对应的信息。比如：/User/1/这样的接口，可以非常容易猜测用户ID的值为多少，总用户数量有多少，也可以非常容易地通过接口进行数据的爬取。
. 性能差 +
自增ID的性能较差，需要在数据库服务器端生成。
. 交互多 +
业务还需要额外执行一次类似 last_insert_id() 的函数才能知道刚才插入的自增值，这需要多一次的网络交互。在海量并发的系统中，多1条SQL，就多一次性能上的开销。
. 局部唯一性 +
最重要的一点，自增ID是局部唯一，只在当前数据库实例中唯一，而不是全局唯一，在任意服务器间都是唯一的。对于目前分布式系统来说，这简直就是噩梦。

==== 业务字段做主键的问题
建议尽量不要用跟业务有关的字段做主键。毕竟，作为项目设计的技术人员，我们谁也无法预测在项目的整个生命周期中，哪个业务字段会因为项目的业务需求而有重复，或者重用之类的情况出现。

==== 淘宝的主键设计
----
订单ID = 时间 + 去重字段 + 用户ID后6位尾号
----

==== 推荐的主键设计
- 非核心业务 ：对应表的主键自增ID，如告警、日志、监控等信息。
- 核心业务 ：主键设计至少应该是全局唯一且是单调递增。全局唯一保证在各系统之间都是唯一的，单调递增是希望插入时不影响数据库性能。

这里推荐最简单的一种主键设计：UUID。

[discrete]
===== UUID
MySQL数据库的UUID组成如下所示：
----
UUID = 时间+UUID版本（16字节）- 时钟序列（4字节） - MAC地址（12字节）
----

.改造UUID
- 若将时间高低位互换，则时间就是单调递增的了，也就变得单调递增了。MySQL 8.0可以更换时间低位和时间高位的存储方式，这样UUID就是有序的UUID了。
- MySQL 8.0还解决了UUID存在的空间占用的问题，除去了UUID字符串中无意义的"-"字符串，并且将字符串用二进制类型保存，这样存储空间降低为了16字节。
+
通过函数uuid_to_bin(@uuid,true)将UUID转化为有序UUID了。全局唯一 + 单调递增，这就是我们想要的主键！
+
.转化方法
----
SET @uuid = UUID();
SELECT @uuid,uuid_to_bin(@uuid),uuid_to_bin(@uuid,TRUE);
----

== 数据库的设计规范
=== 概述
==== 糟糕的数据库设计可能会造成的问题
- 数据冗余、信息重复，存储空间浪费
- 数据更新、插入、删除的异常
- 无法正确表示信息
- 丢失有效信息
- 程序性能差

==== 良好的数据库设计具有的优点
- 节省数据的存储空间
- 能够保证数据的完整性
- 方便进行数据库应用系统的开发

总之，开始设置数据库的时候，我们就需要童视数据表的设计。为了建立冗余较小、结构合理的数据库，设计数据库时必须遵循一定的规则。

=== 范式
==== 相关概念
- 超键：能唯一标识元组的属性集叫做超键。
- 候选键：如果超键不包括多余的属性，那么这个超键就是候选键。（符合主键要求的键，非空且唯一）
- 主键：用户可以从候选键中选择一个作为主键。
- 外键：如果数据表R1中的某属性集不是R1的主键，而是另一个数据表R2的主键，那么这个属性集就是数据表R1的外键。
- 主属性：包含在任一候选键中的属性称为主属性。
- 非主属性：与主属性相对，指的是不包含在任何一个候选键中的属性。

==== 范式分类
目前关系型数据库有六种常见范式，按照范式级别，从低到高分别是：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）

- 第一范式主要是确保数据表中每个字段的值必须具有原子性，也就是说数据表中每个字段的值为不可再次拆分的最小数据单元。
- 第二范式要求，在满足第一范式的基础上，还要满足数据表里的每一条数据记录，都是可唯一标识的。而且所有非主属性字段，都必须完全依赖主键，不能只依赖主键的一部分。如果知道主键的所有属性的值，就可以检索到任何元组（行）的任何属性的任何值。
- 第三范式是在第二范式的基础上，确保数据表中的每一个非主属性字段都和主键字段直接相关，也就是说，要求数据表中的所有非主键字段不能依赖于其他非主属性字段。（即，不能存在非主属性A依赖于非主属性B，非主属性B依赖于主键C的情况）通俗地讲，该规则的意思是所有非主属性之间不能有依赖关系，必须相互独立。
- 巴斯-科德范式（BCNF）指的是，满足第三范式的基础上，消除主属性对候选键的部分依赖或者传递依赖关系。
- 第四范式即在满足巴斯-科德范式（BCNF）的基础上，消除非平凡且非函数依赖的多值依赖（即把同一表内的多对多关系删除）。
- 除了第四范式外，我们还有更高级的第五范式（又称完美范式）和域键范式(DKNF)。在满足第四范式(4NF)的基础上，消除不是由候选键所蕴含的连接依赖。如果关系模式中的每一个连接依赖均由R的候选键所隐含，则称此关系模式符合第五范式。
+
NOTE: 第五范式有待补充、研究。

==== 反范式化
有的时候不能简单按照规范要求设计数据表，因为有的数据看似冗余，其实对业务来说十分重要。这个时候，我们就要遵循业务优先的原则，首先满足业务需求，再尽量减少冗余。

如果数据库中的数据量比较大，系统的UV和PV访问频次比较高，则完全按照MySQL的三大范式设计数据表，读数据时会产生大量的关联查询，在一定程度上会影响数据库的读性能。如果我们想对查询效率进行优化，反范式优化也是一种优化思路。此时，可以通过在数据表中增加冗余字段来提高数据库的读性能。

==== 实际使用
实际业务应用中满足第三范式或巴斯范式即可，同时要适当反范式化。

=== ER模型
==== 三要素
ER 模型中有三个要素，分别是实体（矩形表示）、属性（椭圆表示）和关系（菱形表示）。

NOTE: 实体分为两类，分别是 强实体 和 弱实体 。强实体是指不依赖于其他实体的实体；弱实体是指对另一个实体有很强的依赖关系的实体。

==== 关系的类型  
在 ER 模型的 3 个要素中，关系又可以分为 3 种类型，分别是 一对一、一对多、多对多。

==== ER 模型图转换成数据表  
转换的原则：

- 一个实体通常转换成一个数据表 
- 一个多对多的关系，通常也转换成一个数据表
- 一个 1 对 1，或者 1 对多的关系，往往通过表的 外键 来表达，而不是设计一个新的数据表
- 属性转换成表的字段

=== 数据表的设计原则
- 数据表的个数越少越好
- 数据表中的字段个数越少越好
- 数据表中联合主键的字段个数越少越好
- 使用主键和外键越多越好

NOTE: 这个原则并不是绝对的，有时候我们需要牺牲数据的冗余度来换取数据处理的效率。

=== 数据库对象编写建议
==== 关于库  
- 【强制】库的名称必须控制在32个字符以内，只能使用英文字母、数字和下划线，建议以英文字母开头。
- 【强制】库名中英文 一律小写，不同单词采用下划线分割。须见名知意。
- 【强制】库的名称格式：业务系统名称_子系统名。
- 【强制】库名禁止使用关键字（如type,order等）。
- 【强制】创建数据库时必须显式指定字符集，并且字符集只能是utf8或者utf8mb4。
* 创建数据库SQL举例：CREATE DATABASE crm_fund  DEFAULT CHARACTER SET 'utf8'。
- 【建议】对于程序连接数据库账号，遵循权限最小原则。
* 使用数据库账号只能在一个DB下使用，不准跨库。程序使用的账号原则上不准有drop权限。
- 【建议】临时库以tmp_ 为前缀，并以日期为后缀。备份库以bak_为前缀，并以日期为后缀。

==== 关于表、列  
. 【强制】表和列的名称必须控制在32个字符以内，表名只能使用英文字母、数字和下划线，建议以 英文字母开头 。
. 【强制】 表名、列名一律小写 ，不同单词采用下划线分割。须见名知意。
. 【强制】表名要求有模块名强相关，同一模块的表名尽量使用 统一前缀 。比如：crm_fund_item
. 【强制】创建表时必须 显式指定字符集 为utf8或utf8mb4。
. 【强制】表名、列名禁止使用关键字（如type,order等）。
. 【强制】创建表时必须 显式指定表存储引擎 类型。如无特殊需求，一律为InnoDB。
. 【强制】建表必须有comment。
. 【强制】字段命名应尽可能使用表达实际含义的英文单词或 缩写 。如：公司 ID，不要使用corporation_id, 而用corp_id 即可。
. 【强制】布尔值类型的字段命名为 is_描述 。如member表上表示是否为enabled的会员的字段命名为 is_enabled。
. 【强制】禁止在数据库中存储图片、文件等大的二进制数据。
* 通常文件很大，短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机IO操作，文件很大时，IO操作很耗时。通常存储于文件服务器，数据库只存储文件地址信息。
. 【建议】建表时关于主键：表必须有主键 
* 强制要求主键为id，类型为int或bigint，且为auto_increment 建议使用unsigned无符号型。
* 标识表里每一行主体的字段不要设为主键，建议设为其他字段如user_id，order_id等，并建立unique key索引。因为如果设为主键且主键值为随机插入，则会导致innodb内部页分裂和大量随机I/O，性能下降。
. 【建议】核心表（如用户表）必须有行数据的 创建时间字段 （create_time）和 最后更新时间字段（update_time），便于查问题。
. 【建议】表中所有字段尽量都是 NOT NULL 属性，业务可以根据需要定义 DEFAULT值 。 因为使用NULL值会存在每一行都会占用额外存储空间、数据迁移容易出错、聚合函数计算结果偏差等问题。
. 【建议】所有存储相同数据的 列名和列类型必须一致 （一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）。
. 【建议】中间表（或临时表）用于保留中间结果集，名称以 tmp_  开头。备份表用于备份或抓取源表快照，名称以 bak_ 开头。中间表和备份表定期清理。
. 【建议】创建表时，可以使用可视化工具。这样可以确保表、字段相关的约定都能设置上。
* 实际上，我们通常很少自己写 DDL 语句，可以使用一些可视化工具来创建和操作数据库和数据表。可视化工具除了方便，还能直接帮我们将数据库的结构定义转化成 SQL 语言，方便数据库和数据表结构的导出和导入。

==== 关于索引  
- 【强制】InnoDB表必须主键为id int/bigint auto_increment，且主键值禁止被更新。
- 【强制】InnoDB和MyISAM存储引擎表，索引类型必须为BTREE。
- 【建议】主键的名称以 pk_ 开头，唯一键以 uni_ 或 uk_ 开头，普通索引以 idx_ 开头，一律使用小写格式，以字段的名称或缩写作为后缀。
- 【建议】多单词组成的columnname，取前几个单词首字母，加末单词组成column_name。如:sample 表 member_id 上的索引：idx_sample_mid。
- 【建议】单个表上的索引个数不能超过6个。
- 【建议】在建立索引时，多考虑建立 联合索引，并把区分度最高的字段放在最前面。
- 【建议】在多表 JOIN 的SQL里，保证被驱动表的连接列上有索引，这样JOIN 执行效率最高。
- 【建议】建表或加索引时，保证表里互相不存在 冗余索引。比如：如果表里已经存在key(a,b)，则key(a)为冗余索引，需要删除。

==== SQL编写  
. 【强制】程序端SELECT语句必须指定具体字段名称，禁止写成 *。
. 【建议】程序端insert语句指定具体字段名称，不要写成INSERT INTO t1 VALUES(...)。
. 【建议】除静态表或小表（100行以内），DML语句必须有WHERE条件，且使用索引查找。
. 【建议】INSERT INTO...VALUES(XX),(XX),(XX).. 这里XX的值不要超过5000个。 值过多虽然上线很快，但会引起主从同步延迟。
. 【建议】SELECT语句不要使用UNION，推荐使用UNION ALL，并且UNION子句个数限制在5个以内。
. 【建议】线上环境，多表 JOIN 不要超过5个表。
. 【建议】减少使用ORDER BY，和业务沟通能不排序就不排序，或将排序放到程序端去做。ORDER BY、GROUP BY、DISTINCT 这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。
. 【建议】包含了ORDER BY、GROUP BY、DISTINCT 这些查询的语句，WHERE 条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。
. 【建议】对单表的多次alter操作必须合并为一次对于超过100W行的大表进行alter table，必须经过DBA审核，并在业务低峰期执行，多个alter需整合在一起。 因为alter table会产生表锁，期间阻塞对于该表的所有写入，对于业务可能会产生极大影响。
. 【建议】批量操作数据时，需要控制事务处理间隔时间，进行必要的sleep。
. 【建议】事务里包含SQL不超过5个。因为过长的事务会导致锁数据较久，MySQL内部缓存、连接消耗过多等问题。
. 【建议】事务里更新语句尽量基于主键或UNIQUE KEY，如 `UPDATE... WHERE id=XX;` 否则会产生间隙锁，内部扩大锁定范围，导致系统性能下降，产生死锁。

=== PowerDesigner的使用
PowerDesigner是一款开发人员常用的数据库建模工具，用户利用该软件可以方便地制作 数据流程图 、概念数据模型 、 物理数据模型 ，它几乎包括了数据库模型设计的全过程，是Sybase公司为企业建模和设计提供的一套完整的集成化企业级建模解决方案。

具体使用见视频： https://www.bilibili.com/video/BV1iq4y1u7vj?p=158[PowerDesignert创健概念、物理数据模型]。

== 数据库其它调优策略[待补充...]
=== 数据库调优的措施
==== 调优的目标
- 尽可能节省系统资源，以便系统可以提供更大负荷的服务。（吞吐量更大）
- 合理的结构设计和参数调整，以提高用户操作响应的速度。（响应速度更快）
- 减少系统的瓶颈，提高MySOL数据库整体的性能。

==== 如何定位调优问题
- 用户的反馈（主要）
- 日志分析（主要）
- 服务器资源使用监控
- 数据库内部状况监控
- 其它

除了活动会话监控以外，我们也可以对事务、锁等待等进行监控，这些都可以帮助我们对数据库的运行状态有更全面的认识。

==== 调优的维度和步骤[待补充...]
我们需要调优的对象是整个数据库管理系统，它不仅包括 SQL 查询，还包括数据库的部署配置、架构等。

- 第1步：选择适合的 DBMS 

- 第2步：优化表设计  

- 第3步：优化逻辑查询  

- 第4步：优化物理查询

- 第5步：使用 Redis 或 Memcached 作为缓存

- 第6步：库级优化  
* 读写分离

* 数据分片

=== 优化MySQL服务器[待补充...]
==== 优化服务器硬件

==== 优化MySQL的参数

=== 优化数据库结构[待补充...]
==== 拆分表：冷热数据分离
==== 增加中间表
==== 增加冗余字段
==== 优化数据类型
==== 优化插入记录的速度
==== 使用非空约束
==== 分析表、检查表与优化表

=== 大表优化[待补充...]
==== 限定查询的范围
==== 读/写分离
==== 垂直拆分
==== 水平拆分

=== 其它调优策略[待补充...]
==== 服务器语句超时处理
==== 创建全局通用表空间
==== MySQL 8.0新特性：隐藏索引对调优的帮助